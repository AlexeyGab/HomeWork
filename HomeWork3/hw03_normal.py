import itertools

# Задание-1:
# Напишите функцию, возвращающую ряд Фибоначчи с n-элемента до m-элемента.
# Первыми элементами ряда считать цифры 1 1

print("Задача 1:")

def fibonacci(n, m):
    if(n > m):
        n, m = m, n

    series = [1,1]
    for i in range(2, m):
        series.append(series[i-1] + series[i-2])

    return series[n:m]

print(fibonacci(10,3))

# Задача-2:
# Напишите функцию, сортирующую принимаемый список по возрастанию.
# Для сортировки используйте любой алгоритм (например пузырьковый).
# Для решения данной задачи нельзя использовать встроенную функцию и метод sort()
print("Задача 2:")

# Сделаем сортировку пузырьком
def sort_to_max(origin_list):
    sort_continue = True
    new_list = origin_list[:]
    while(sort_continue):
        # print(origin_list)
        sort_continue = False
        for i in range(1, len(new_list)):
            if new_list[i - 1] > new_list[i]:
                new_list[i - 1], new_list[i] = new_list[i], new_list[i - 1]
                sort_continue = True
    return new_list

print(sort_to_max([2, 10, -12, 2.5, 20, -11, 4, 4, 0]))


# Задача-3:
# Напишите собственную реализацию стандартной функции filter.
# Разумеется, внутри нельзя использовать саму функцию filter.
print("Задача 3:")

# Пример использования функции filter, чтобы понять что вобще она делает и как с ней работать
# mixed = ['мак', 'просо', 'мак', 'мак', 'просо', 'мак', 'просо', 'просо', 'просо', 'мак']
# zolushka = list(filter(lambda x: x == 'мак', mixed))
# print(zolushka)
# ['мак', 'мак', 'мак', 'мак', 'мак']

# Значит нам надо в свою функцию принимать в качестве аргумента любую другую функцию которая будет возвращать
#  True или False. как вот эта (lambda x: x == 'мак'). Вторым аргументом идет массив для фильтрации
# В своей реализации функции my_filter будем перебирать каждый элемент из массива и подставлять в функцию,
#  полученную из первого аргумента. Если переданная функция возвращает True то добавим проверяемый
#  элемент в новый массив.

def my_filter(function, buf):
    fBuf = []
    for value in buf:
        if function(value):
            fBuf.append(value)
    return fBuf

mBuf1 = [0,1,2,3,4,0,1,2,3,4]
mBuf2 = ["Привет", "Пока", "До встречи", "Салют", "Привет"]

print(my_filter(lambda x: x > 2, mBuf1))
print(my_filter(lambda x: x == "Привет", mBuf2))


# Задача-4:
# Даны четыре точки А1(х1, у1), А2(x2 ,у2), А3(x3 , у3), А4(х4, у4).
# Определить, будут ли они вершинами параллелограмма.
print("Задача 4:")

  #   B--->C
  #  /    /
  # A--->D

# Воспользуемся тем фактом что параллелограммом является фигура, если две ее стороны равны по длине и параллельны
#  т.е. вектор BC должен быть равен AD или вектор AB должен быть равен DC
#

# Параллелограмм
A1 = (0, 0)
A2 = (1, 10)
A3 = (11, 10)
A4 = (10, 0)

# Просто многоугольник
# A1 = (0, 5)
# A2 = (1, 8)
# A3 = (11, 10)
# A4 = (10, 0)


def CheckVectors(A, B, C, D):
    BC = (C[0] - B[0], C[1] - B[1])
    AD = (D[0] - A[0], D[1] - A[1])
    return AD == BC

# Если у нас 4 точки, значит у нас 4! = 24 разных вариантов последовательности точек
# Проверяет точки в любом порядке.
def searchVectors(a, b, c, d):
    points = [a, b, c, d]
    for a, b, c, d in itertools.permutations(points):
        if CheckVectors(a, b, c, d):
            return True
    return False

print(searchVectors(A1, A2, A3, A4))